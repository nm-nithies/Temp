import os
import sys
import numpy as np
import logging

logger = logging.getLogger(__name__)

def validate_and_extract_constants(optimized_model, legalize_replace_input_with_constant):
    """
    Validates and extracts constant input values for legalize_replace_input_with_constant argument.

    Args:
        optimized_model (onnx.ModelProto): ONNX model
        legalize_replace_input_with_constant (list[list[str]]): 
            e.g., [['input1', '1.0'], ['input2', 'input2.npy'], ['input3', '1', '2', '3']]

    Returns:
        dict: {input_name: constant_value (np.ndarray)}
    """
    input_node_shapes, input_node_types = get_input_shapes_and_types(optimized_model)
    replace_input_node_dict = {}

    for values in legalize_replace_input_with_constant:
        if len(values) < 2:
            logger.error(f"[ERROR] Each entry must have an input name and at least one value. Got: {values}")
            sys.exit(-1)

        input_name, *val_list = values
        if input_name not in input_node_shapes:
            logger.error(f"[ERROR] Input name '{input_name}' not found in graph nodes")
            sys.exit(-1)

        expected_dtype = input_node_types[input_name]
        expected_shape = input_node_shapes[input_name]

        if any(dim == 0 for dim in expected_shape):
            logger.warning(f"[WARN] Input '{input_name}' has a dimension of size 0. This may lead to unexpected behavior.")

        # Case 1: .npy file
        if len(val_list) == 1 and val_list[0].endswith('.npy'):
            val = val_list[0]
            if not os.path.isfile(val):
                logger.error(f"[ERROR] Numpy file '{val}' not found for input '{input_name}'")
                sys.exit(-1)
            try:
                loaded_val = np.load(val)
            except Exception as e:
                logger.error(f"[ERROR] Failed to load .npy file '{val}' for '{input_name}': {e}")
                sys.exit(-1)

            if loaded_val.dtype != expected_dtype:
                logger.error(f"[ERROR] '{input_name}' expected dtype {expected_dtype}, but got {loaded_val.dtype}")
                sys.exit(-1)

            if list(loaded_val.shape) != list(expected_shape):
                logger.error(f"[ERROR] '{input_name}' expected shape {expected_shape}, but got {loaded_val.shape}")
                sys.exit(-1)

            logger.info(f"Input '{input_name}' is replaced with file '{val}'")

        # Case 2: scalar value
        elif len(val_list) == 1:
            val = val_list[0]
            try:
                if not val.replace('.', '', 1).replace('-', '', 1).isdigit():
                    raise ValueError(f"Invalid numeric format: '{val}'")

                if np.issubdtype(expected_dtype, np.integer):
                    scalar_val = expected_dtype.type(int(val))
                elif np.issubdtype(expected_dtype, np.floating):
                    scalar_val = expected_dtype.type(float(val))
                else:
                    logger.error(f"[ERROR] Unsupported dtype '{expected_dtype}' for input '{input_name}'")
                    sys.exit(-1)

                if scalar_val == 0 and np.prod(expected_shape) > 1:
                    logger.warning(f"[WARN] Scalar value 0 is being broadcasted to shape {expected_shape}. "
                                   f"This might unintentionally zero out the input.")

                loaded_val = np.full(expected_shape, scalar_val, dtype=expected_dtype)
                logger.info(f"Input '{input_name}' is replaced with scalar value '{scalar_val}', "
                            f"broadcasted to shape {expected_shape}")

            except Exception as e:
                logger.error(f"[ERROR] Invalid scalar value '{val}' for input '{input_name}': {e}")
                sys.exit(-1)

        # Case 3: multi-value constant â†’ attempt reshape
        else:
            try:
                if not all(v.replace('.', '', 1).replace('-', '', 1).isdigit() for v in val_list):
                    logger.error(f"[ERROR] One or more values in {val_list} are not valid numbers")
                    sys.exit(-1)

                has_float = any('.' in v or 'e' in v.lower() for v in val_list)
                has_int = all(v.isdigit() or (v.startswith('-') and v[1:].isdigit()) for v in val_list)

                if has_int and has_float:
                    logger.error(f"[ERROR] Mixed int and float types are not supported in multi-value input: {val_list}")
                    sys.exit(-1)

                if np.issubdtype(expected_dtype, np.integer):
                    flat_array = np.array([int(v) for v in val_list], dtype=expected_dtype)
                elif np.issubdtype(expected_dtype, np.floating):
                    flat_array = np.array([float(v) for v in val_list], dtype=expected_dtype)
                else:
                    logger.error(f"[ERROR] Unsupported dtype '{expected_dtype}' for input '{input_name}'")
                    sys.exit(-1)

                try:
                    loaded_val = flat_array.reshape(expected_shape)
                except Exception as e:
                    logger.error(f"[ERROR] Cannot reshape values {flat_array.tolist()} to shape {expected_shape} "
                                 f"for input '{input_name}': {e}")
                    sys.exit(-1)

                logger.info(f"Input '{input_name}' is replaced with reshaped array of shape {loaded_val.shape}")

            except Exception as e:
                logger.error(f"[ERROR] Failed to parse or reshape values '{val_list}' for input '{input_name}': {e}")
                sys.exit(-1)

        replace_input_node_dict[input_name] = loaded_val

    return replace_input_node_dict
