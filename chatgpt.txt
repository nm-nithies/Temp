def is_valid_scatter_for_slice_concat(indices, updates_shape, data_shape):
    """
    This method validates if a ScatterND operation with given indices and updates can be
    replaced with a Slice + Concat pattern for a data tensor of shape (N, C, W).

    This replacement is valid only when each update targets the same channel and
    starting width (usually zero), with exactly one update per batch, and the
    indices are aligned sequentially with batch indices
    (i.e., indices are of the form (i, fixed_channel, 0) for each batch i).

    Args:
        indices: numpy array of shape (N, 1, 1, 3) or equivalent (flexible format)
        updates_shape: list(N, 1, W)
        data_shape: list(N, C, W)

    Returns:
        True if valid for replacement, else False
    """

    if indices.ndim != 4 or indices.shape[-1] != 3:
        return False

    N, C, W = data_shape

    # Batch size must match
    if indices.shape[0] != updates_shape[0] or indices.shape[0] != N:
        return False

    # Ensure update shape is (N, 1, 1)
    if len(updates_shape) != len(data_shape) or updates_shape != [N, 1, 1]:
        return False
    
    dim_with_3 = data_shape.index(3)
    if indices.shape[-1] != 3:
        return False
    
    dim_indices = indices[..., dim_with_3]
    first_value = dim_indices.flat[0]
    all_same = np.all(dim_indices == first_value)
    
    if not all_same:
        return False

    return True
