def broadcast_shapes(shape1, shape2):
    shape1 = list(shape1)
    shape2 = list(shape2)
    
    # Reverse shapes to align from right to left
    rev_shape1 = shape1[::-1]
    rev_shape2 = shape2[::-1]
    
    result_rev = []
    for dim1, dim2 in zip(rev_shape1, rev_shape2):
        if dim1 == 1:
            result_rev.append(dim2)
        elif dim2 == 1:
            result_rev.append(dim1)
        elif dim1 == dim2:
            result_rev.append(dim1)
        else:
            raise ValueError(f"Shapes {tuple(shape1)} and {tuple(shape2)} are not broadcastable")
    
    # Pad remaining dimensions with the longer shape's values
    max_len = max(len(rev_shape1), len(rev_shape2))
    if len(rev_shape1) > len(rev_shape2):
        result_rev.extend(rev_shape1[len(rev_shape2):])
    else:
        result_rev.extend(rev_shape2[len(rev_shape1):])
    
    # Reverse back to original order
    return tuple(result_rev[::-1])

# Test cases
print(broadcast_shapes((1280, 320, 20, 20), (1280,)))               # (1280, 1, 1, 1)
print(broadcast_shapes((120, 320, 20, 20), (320,)))                 # (1, 320, 1, 1)
print(broadcast_shapes((12, 32, 1, 1), (12, 32)))                   # (12, 32, 1, 1)
print(broadcast_shapes((1, 3, 20, 20), (20, 20)))                   # (1, 3, 20, 20)
print(broadcast_shapes((5, 4), (1,)))                               # (5, 4)
print(broadcast_shapes((15, 3, 5), (15, 1, 5)))                     # (15, 3, 5)
print(broadcast_shapes((8, 1, 6, 1), (7, 1, 5)))                    # Raises ValueError
